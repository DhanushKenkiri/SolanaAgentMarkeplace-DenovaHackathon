{
  "name": "agent_registry",
  "description": "Layer2Agents On-Chain Agent Registry",
  "framework": "anchor",
  "files": {
    "src/lib.rs": "use anchor_lang::prelude::*;\r\n\r\ndeclare_id!(\"FJ4JML2n58cV1FgVFCqqW56YKu2wyK8DJF3jxGRhW1fi\");\r\n\r\n#[program]\r\npub mod agent_registry {\r\n    use super::*;\r\n\r\n    /// Initialize the registry state\r\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\r\n        let registry = &mut ctx.accounts.registry;\r\n        registry.authority = ctx.accounts.authority.key();\r\n        registry.agent_count = 0;\r\n        registry.bump = ctx.bumps.registry;\r\n        msg!(\"Agent Registry initialized!\");\r\n        Ok(())\r\n    }\r\n\r\n    /// Register a new agent on-chain\r\n    pub fn register_agent(\r\n        ctx: Context<RegisterAgent>,\r\n        agent_id: String,\r\n        name: String,\r\n        description: String,\r\n        api_url: String,\r\n        tags: Vec<String>,\r\n        price_per_task: u64,\r\n        accepted_payment_tokens: Vec<Pubkey>,\r\n        metadata_uri: String,\r\n    ) -> Result<()> {\r\n        require!(agent_id.len() <= 64, RegistryError::AgentIdTooLong);\r\n        require!(name.len() <= 128, RegistryError::NameTooLong);\r\n        require!(description.len() <= 512, RegistryError::DescriptionTooLong);\r\n        require!(api_url.len() <= 256, RegistryError::ApiUrlTooLong);\r\n        require!(tags.len() <= 10, RegistryError::TooManyTags);\r\n        require!(metadata_uri.len() <= 256, RegistryError::MetadataUriTooLong);\r\n\r\n        // Get keys before mutable borrow\r\n        let agent_key = ctx.accounts.agent.key();\r\n        let owner_key = ctx.accounts.owner.key();\r\n        let clock = Clock::get()?;\r\n\r\n        let agent = &mut ctx.accounts.agent;\r\n        let registry = &mut ctx.accounts.registry;\r\n\r\n        agent.owner = owner_key;\r\n        agent.agent_id = agent_id.clone();\r\n        agent.name = name.clone();\r\n        agent.description = description;\r\n        agent.api_url = api_url.clone();\r\n        agent.tags = tags;\r\n        agent.price_per_task = price_per_task;\r\n        agent.accepted_payment_tokens = accepted_payment_tokens;\r\n        agent.metadata_uri = metadata_uri;\r\n        agent.status = AgentStatus::Active;\r\n        agent.created_at = clock.unix_timestamp;\r\n        agent.updated_at = clock.unix_timestamp;\r\n        agent.total_tasks_completed = 0;\r\n        agent.total_earnings = 0;\r\n        agent.rating_sum = 0;\r\n        agent.rating_count = 0;\r\n        agent.bump = ctx.bumps.agent;\r\n\r\n        registry.agent_count += 1;\r\n\r\n        emit!(AgentRegistered {\r\n            agent: agent_key,\r\n            owner: owner_key,\r\n            agent_id,\r\n            name,\r\n            api_url,\r\n            timestamp: clock.unix_timestamp,\r\n        });\r\n\r\n        msg!(\"Agent '{}' registered successfully!\", agent.name);\r\n        Ok(())\r\n    }\r\n\r\n    /// Update an existing agent\r\n    pub fn update_agent(\r\n        ctx: Context<UpdateAgent>,\r\n        name: Option<String>,\r\n        description: Option<String>,\r\n        api_url: Option<String>,\r\n        tags: Option<Vec<String>>,\r\n        price_per_task: Option<u64>,\r\n        accepted_payment_tokens: Option<Vec<Pubkey>>,\r\n        metadata_uri: Option<String>,\r\n    ) -> Result<()> {\r\n        // Get keys before mutable borrow\r\n        let agent_key = ctx.accounts.agent.key();\r\n        let owner_key = ctx.accounts.owner.key();\r\n        let clock = Clock::get()?;\r\n\r\n        let agent = &mut ctx.accounts.agent;\r\n\r\n        if let Some(n) = name {\r\n            require!(n.len() <= 128, RegistryError::NameTooLong);\r\n            agent.name = n;\r\n        }\r\n        if let Some(d) = description {\r\n            require!(d.len() <= 512, RegistryError::DescriptionTooLong);\r\n            agent.description = d;\r\n        }\r\n        if let Some(u) = api_url {\r\n            require!(u.len() <= 256, RegistryError::ApiUrlTooLong);\r\n            agent.api_url = u;\r\n        }\r\n        if let Some(t) = tags {\r\n            require!(t.len() <= 10, RegistryError::TooManyTags);\r\n            agent.tags = t;\r\n        }\r\n        if let Some(p) = price_per_task {\r\n            agent.price_per_task = p;\r\n        }\r\n        if let Some(tokens) = accepted_payment_tokens {\r\n            agent.accepted_payment_tokens = tokens;\r\n        }\r\n        if let Some(uri) = metadata_uri {\r\n            require!(uri.len() <= 256, RegistryError::MetadataUriTooLong);\r\n            agent.metadata_uri = uri;\r\n        }\r\n\r\n        agent.updated_at = clock.unix_timestamp;\r\n\r\n        emit!(AgentUpdated {\r\n            agent: agent_key,\r\n            owner: owner_key,\r\n            timestamp: clock.unix_timestamp,\r\n        });\r\n\r\n        msg!(\"Agent '{}' updated successfully!\", agent.name);\r\n        Ok(())\r\n    }\r\n\r\n    /// Set agent status (active, paused, deprecated)\r\n    pub fn set_agent_status(ctx: Context<UpdateAgent>, status: AgentStatus) -> Result<()> {\r\n        let agent = &mut ctx.accounts.agent;\r\n        let clock = Clock::get()?;\r\n\r\n        agent.status = status.clone();\r\n        agent.updated_at = clock.unix_timestamp;\r\n\r\n        emit!(AgentStatusChanged {\r\n            agent: ctx.accounts.agent.key(),\r\n            owner: ctx.accounts.owner.key(),\r\n            status,\r\n            timestamp: clock.unix_timestamp,\r\n        });\r\n\r\n        msg!(\"Agent status updated!\");\r\n        Ok(())\r\n    }\r\n\r\n    /// Deregister (close) an agent account\r\n    pub fn deregister_agent(ctx: Context<DeregisterAgent>) -> Result<()> {\r\n        let registry = &mut ctx.accounts.registry;\r\n        let clock = Clock::get()?;\r\n\r\n        registry.agent_count = registry.agent_count.saturating_sub(1);\r\n\r\n        emit!(AgentDeregistered {\r\n            agent: ctx.accounts.agent.key(),\r\n            owner: ctx.accounts.owner.key(),\r\n            agent_id: ctx.accounts.agent.agent_id.clone(),\r\n            timestamp: clock.unix_timestamp,\r\n        });\r\n\r\n        msg!(\"Agent deregistered successfully!\");\r\n        Ok(())\r\n    }\r\n\r\n    /// Record a completed task for an agent (called by authorized services)\r\n    pub fn record_task_completion(\r\n        ctx: Context<RecordTask>,\r\n        earnings: u64,\r\n        rating: Option<u8>,\r\n    ) -> Result<()> {\r\n        // Get key before mutable borrow\r\n        let agent_key = ctx.accounts.agent.key();\r\n        let clock = Clock::get()?;\r\n\r\n        let agent = &mut ctx.accounts.agent;\r\n\r\n        agent.total_tasks_completed += 1;\r\n        agent.total_earnings += earnings;\r\n\r\n        if let Some(r) = rating {\r\n            require!(r <= 5, RegistryError::InvalidRating);\r\n            agent.rating_sum += r as u64;\r\n            agent.rating_count += 1;\r\n        }\r\n\r\n        let total_tasks = agent.total_tasks_completed;\r\n        agent.updated_at = clock.unix_timestamp;\r\n\r\n        emit!(TaskCompleted {\r\n            agent: agent_key,\r\n            earnings,\r\n            rating,\r\n            total_tasks,\r\n            timestamp: clock.unix_timestamp,\r\n        });\r\n\r\n        msg!(\"Task recorded for agent!\");\r\n        Ok(())\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// Account Contexts\r\n// ============================================================================\r\n\r\n#[derive(Accounts)]\r\npub struct Initialize<'info> {\r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = 8 + Registry::INIT_SPACE,\r\n        seeds = [b\"registry\"],\r\n        bump\r\n    )]\r\n    pub registry: Account<'info, Registry>,\r\n    \r\n    #[account(mut)]\r\n    pub authority: Signer<'info>,\r\n    \r\n    pub system_program: Program<'info, System>,\r\n}\r\n\r\n#[derive(Accounts)]\r\n#[instruction(agent_id: String)]\r\npub struct RegisterAgent<'info> {\r\n    #[account(\r\n        mut,\r\n        seeds = [b\"registry\"],\r\n        bump = registry.bump\r\n    )]\r\n    pub registry: Account<'info, Registry>,\r\n\r\n    #[account(\r\n        init,\r\n        payer = owner,\r\n        space = 8 + Agent::INIT_SPACE,\r\n        seeds = [b\"agent\", agent_id.as_bytes()],\r\n        bump\r\n    )]\r\n    pub agent: Account<'info, Agent>,\r\n    \r\n    #[account(mut)]\r\n    pub owner: Signer<'info>,\r\n    \r\n    pub system_program: Program<'info, System>,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateAgent<'info> {\r\n    #[account(\r\n        mut,\r\n        has_one = owner,\r\n        seeds = [b\"agent\", agent.agent_id.as_bytes()],\r\n        bump = agent.bump\r\n    )]\r\n    pub agent: Account<'info, Agent>,\r\n    \r\n    pub owner: Signer<'info>,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct DeregisterAgent<'info> {\r\n    #[account(\r\n        mut,\r\n        seeds = [b\"registry\"],\r\n        bump = registry.bump\r\n    )]\r\n    pub registry: Account<'info, Registry>,\r\n\r\n    #[account(\r\n        mut,\r\n        has_one = owner,\r\n        close = owner,\r\n        seeds = [b\"agent\", agent.agent_id.as_bytes()],\r\n        bump = agent.bump\r\n    )]\r\n    pub agent: Account<'info, Agent>,\r\n    \r\n    #[account(mut)]\r\n    pub owner: Signer<'info>,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct RecordTask<'info> {\r\n    #[account(\r\n        mut,\r\n        seeds = [b\"agent\", agent.agent_id.as_bytes()],\r\n        bump = agent.bump\r\n    )]\r\n    pub agent: Account<'info, Agent>,\r\n    \r\n    /// The authority that can record tasks (could be the agent owner or a designated service)\r\n    pub authority: Signer<'info>,\r\n}\r\n\r\n// ============================================================================\r\n// State Accounts\r\n// ============================================================================\r\n\r\n#[account]\r\n#[derive(InitSpace)]\r\npub struct Registry {\r\n    /// The authority who initialized the registry\r\n    pub authority: Pubkey,\r\n    /// Total number of registered agents\r\n    pub agent_count: u64,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\n#[account]\r\n#[derive(InitSpace)]\r\npub struct Agent {\r\n    /// Owner wallet that registered this agent\r\n    pub owner: Pubkey,\r\n    /// Unique identifier for the agent\r\n    #[max_len(64)]\r\n    pub agent_id: String,\r\n    /// Human-readable name\r\n    #[max_len(128)]\r\n    pub name: String,\r\n    /// Description of what the agent does\r\n    #[max_len(512)]\r\n    pub description: String,\r\n    /// API endpoint URL (MIP-003 compatible)\r\n    #[max_len(256)]\r\n    pub api_url: String,\r\n    /// Tags/categories for discovery\r\n    #[max_len(10, 32)]\r\n    pub tags: Vec<String>,\r\n    /// Price per task in lamports (or smallest token unit)\r\n    pub price_per_task: u64,\r\n    /// Accepted payment token mints\r\n    #[max_len(5)]\r\n    pub accepted_payment_tokens: Vec<Pubkey>,\r\n    /// URI to off-chain metadata (IPFS, Arweave, etc.)\r\n    #[max_len(256)]\r\n    pub metadata_uri: String,\r\n    /// Current status\r\n    pub status: AgentStatus,\r\n    /// Unix timestamp of registration\r\n    pub created_at: i64,\r\n    /// Unix timestamp of last update\r\n    pub updated_at: i64,\r\n    /// Total tasks completed\r\n    pub total_tasks_completed: u64,\r\n    /// Total earnings in lamports\r\n    pub total_earnings: u64,\r\n    /// Sum of all ratings (for calculating average)\r\n    pub rating_sum: u64,\r\n    /// Number of ratings received\r\n    pub rating_count: u64,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq, InitSpace)]\r\npub enum AgentStatus {\r\n    Active,\r\n    Paused,\r\n    Deprecated,\r\n}\r\n\r\n// ============================================================================\r\n// Events\r\n// ============================================================================\r\n\r\n#[event]\r\npub struct AgentRegistered {\r\n    pub agent: Pubkey,\r\n    pub owner: Pubkey,\r\n    pub agent_id: String,\r\n    pub name: String,\r\n    pub api_url: String,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct AgentUpdated {\r\n    pub agent: Pubkey,\r\n    pub owner: Pubkey,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct AgentStatusChanged {\r\n    pub agent: Pubkey,\r\n    pub owner: Pubkey,\r\n    pub status: AgentStatus,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct AgentDeregistered {\r\n    pub agent: Pubkey,\r\n    pub owner: Pubkey,\r\n    pub agent_id: String,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct TaskCompleted {\r\n    pub agent: Pubkey,\r\n    pub earnings: u64,\r\n    pub rating: Option<u8>,\r\n    pub total_tasks: u64,\r\n    pub timestamp: i64,\r\n}\r\n\r\n// ============================================================================\r\n// Errors\r\n// ============================================================================\r\n\r\n#[error_code]\r\npub enum RegistryError {\r\n    #[msg(\"Agent ID exceeds maximum length of 64 characters\")]\r\n    AgentIdTooLong,\r\n    #[msg(\"Name exceeds maximum length of 128 characters\")]\r\n    NameTooLong,\r\n    #[msg(\"Description exceeds maximum length of 512 characters\")]\r\n    DescriptionTooLong,\r\n    #[msg(\"API URL exceeds maximum length of 256 characters\")]\r\n    ApiUrlTooLong,\r\n    #[msg(\"Too many tags (maximum 10)\")]\r\n    TooManyTags,\r\n    #[msg(\"Metadata URI exceeds maximum length of 256 characters\")]\r\n    MetadataUriTooLong,\r\n    #[msg(\"Rating must be between 0 and 5\")]\r\n    InvalidRating,\r\n    #[msg(\"Agent is not active\")]\r\n    AgentNotActive,\r\n    #[msg(\"Unauthorized\")]\r\n    Unauthorized,\r\n}\r\n",
    "Cargo.toml": "[package]\r\nname = \"agent-registry\"\r\nversion = \"0.1.0\"\r\ndescription = \"On-chain AI Agent Registry for Layer2Agents marketplace on Solana\"\r\nedition = \"2021\"\r\nlicense = \"MIT\"\r\nrepository = \"https://github.com/layer2agents/onchain-registry\"\r\n\r\n[lib]\r\ncrate-type = [\"cdylib\", \"lib\"]\r\nname = \"agent_registry\"\r\n\r\n[features]\r\ndefault = []\r\ncpi = [\"no-entrypoint\"]\r\nno-entrypoint = []\r\nno-idl = []\r\nno-log-ix-name = []\r\n\r\n[dependencies]\r\nanchor-lang = \"0.32.1\"\r\n"
  },
  "instructions": "\n## How to Build on Solana Playground\n\n1. Go to https://beta.solpg.io/\n2. Click \"Import\" or create a new Anchor project\n3. Replace the contents of src/lib.rs with the code below\n4. Update Cargo.toml with the dependencies\n5. Click \"Build\"\n6. Once built, click \"Deploy\" to deploy to devnet\n7. Copy the Program ID and update your config files\n\n## After Deployment\n\nUpdate these files with your new Program ID:\n- onchain-registry/Anchor.toml\n- onchain-registry/programs/agent-registry/src/lib.rs (declare_id!)\n- onchain-registry/sdk/src/index.ts\n- layer2agents/src/lib/onchain-registry.ts\n"
}